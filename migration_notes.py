#PROCEDURE FOR CREATING MIGRATIONS
# 1. If not installed, install pip install alembic
# 2. Initialize alembic init migrations (alembic init alembic)
# 3. Configure the migration environment - alembic.ini and env.py contain important settings that need to be changed to work with our database and SQLAlchemy app specifically. alembic.ini contains a sqlalchemy.url setting on line 58 that points to the project database. Since we're starting to make changes to existing databases, we're going to use a .db file instead of working in memory
# 4. Navigate into models.py to start designing our database with SQLAlchemy.#!/usr/bin/env python3
# from sqlalchemy import create_engine
# from sqlalchemy.ext.declarative import declarative_base

# engine = create_engine('sqlite:///migrations_test.db')

# Base = declarative_base()

#5. Next, we need to configure env.py to point to the metadata attribute of our new declarative_base object. Alembic will use this metadata to compare the structure of the database schema to the models as they are defined in SQLAlchemy. Now, let's update migrations/env.py:
# migrations/env.py
# search file for target_metadata (line 21)
# ---->from models import Base
# ---->target_metadata = Base.metadata

#6. Generating our First Migration --> % alembic revision -m "Empty Init"

# To generate our database, run the following command --> $ alembic upgrade head. This upgrades the database to the head, or newest revision. 

# 7. Add our data model to the models.py 
# # eample code;
# from datetime import datetime

# from sqlalchemy import create_engine, desc
# from sqlalchemy import (CheckConstraint, UniqueConstraint,
#     Column, DateTime, Integer, String)

# from sqlalchemy.ext.declarative import declarative_base

# engine = create_engine('sqlite:///migrations_test.db')

# Base = declarative_base()

# class Student(Base):
#     __tablename__ = 'students'
#     __table_args__ = (
#         UniqueConstraint('email',
#             name='unique_email'),
#         CheckConstraint('grade BETWEEN 1 AND 12',
#             name='grade_between_1_and_12')
#     )

#     id = Column(Integer(), primary_key=True)
#     name = Column(String(), index=True)
#     email = Column(String(55))
#     grade = Column(Integer())
#     birthday = Column(DateTime())
#     enrolled_date = Column(DateTime(), default=datetime.now())

#     def __repr__(self):
#         return f"Student {self.id}: " \
#             + f"{self.name}, " \
#             + f"Grade {self.grade}"

# With our Student model added in, we can now create a migration to add the students table to our database. This is a simple migration, so we can take advantage of Alembic's ability to generate the code for us automatically:

# $  alembic revision --autogenerate -m "Added Student model"

# INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
# INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
# INFO  [alembic.autogenerate.compare] Detected added table 'students'
# INFO  [alembic.autogenerate.compare] Detected added index 'ix_students_name' on '['name']'
#   Generating /python-p3-migrations-and-alembic/app/migrations/versions/361dae855898_added_model.py ...  done

# 8. Run autogenerated migration to create the student table: $ alembic upgrade head


# Open up migrations_test.db and you should see two tables: alembic_version, which stores the migration ID for the current state of the database, and students, which contains all of the columns, keys, and constraints that we included in our model!